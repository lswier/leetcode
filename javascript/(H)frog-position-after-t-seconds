/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {number} t
 * @param {number} target
 * @return {number}
 */

var frogPosition = function(n, edges, t, target) {
    
    target--; // Account for zero-indexed arrays.
    
    // create adjList graph
    var g = Array(n);
    for (let i = 0; i < n; i++) g[i] = [];
    for (let i = 0; i < edges.length; i++){
        let src = edges[i][0]-1;    // -1 to account for 0-indexing
        let dst = edges[i][1]-1;    // -1 to account for 0-indexing
        g[src].push(dst);
        g[dst].push(src);
    }
    
    // create visited array
    var visited = Array(n).fill(false);
    
    // iterate through graph DFS
    let v = 0;
    let curTime = 0; 
    return DFS(g, visited, v, curTime, t, target, 1);
}

function DFS(g, visited, v, curTime, t, target, prob){
    visited[v] = true;
    
    // create adjacency list for current node and DFS on each entry.
    let adjNodes = g[v].filter(i => visited[i] != true);
    
    // If we have reached the target node and:
    //  - it is a leaf node (repeated jumps on same node)
    //  - the current time is at the bounds set by t
    if (v == target && (adjNodes.length == 0 || curTime == t)) {
        return prob;
    }
    
    // if the current time permits further jumps, recursively DFS.
    if (curTime < t){
        curTime++;
        // adjust probability based on number of children in list.
        let p = prob/adjNodes.length;
        for (let i = 0; i < adjNodes.length; i++){
            prob = DFS(g, visited, adjNodes[i], curTime, t, target, p);
            if (prob > 0) return prob;
        }
    }
    return 0;
}

